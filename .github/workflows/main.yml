name: Combined Playlist Update

on:
  workflow_dispatch:
  schedule:
    # Runs every 40 minutes past the hour.
    - cron: '*/40 * * * *'

jobs:
  update-playlist:
    runs-on: ubuntu-latest
    container:
      # Use a Playwright container with all necessary dependencies.
      image: mcr.microsoft.com/playwright:v1.55.0-noble
    env:
      HOME: /root # This is crucial to fix permissions and sandbox issues inside the container.

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies and set up Python virtual environment
        run: |
          # Update package list and install python3-venv.
          apt-get update
          apt-get install -y python3-venv
          
          # Create and activate a Python virtual environment.
          python3 -m venv venv
          source venv/bin/activate
          
          # Upgrade pip and install all required Python packages.
          python -m pip install --upgrade pip
          pip install playwright==1.55.0 aiohttp dropbox httpx requests
        shell: bash

      - name: Download scripts and channels.txt
        run: |
          # Use curl to download each script from its unique tinyurl link.
          curl -L -o FSC.py "https://tinyurl.com/m4evvh4v"
          curl -L -o FS.py "https://tinyurl.com/mv5ew6m5"
          curl -L -o PP.py "https://tinyurl.com/muuurv94"
          curl -L -o TML.py "https://tinyurl.com/mrmtxffk"
          curl -L -o WC.py "https://tinyurl.com/35jt8wtm"
          
          # Download the channels.txt file from the specified URL.
          curl -L -o channels.txt "https://tinyurl.com/4ze5nm6p"
        shell: bash

      - name: Download remote playlists from channels.txt 📥
        # This new step downloads all remote content before scripts run.
        # It names the files based on their line number for easy tracking.
        run: |
          echo "Starting download of remote playlists from channels.txt..."
          if [ -f "channels.txt" ]; then
            line_number=0
            # Read channels.txt line by line.
            while read -r url; do
              # Increment line number for unique file naming.
              line_number=$((line_number + 1))
              # Ensure the line is not empty and doesn't start with a # (a comment).
              if [[ ! -z "$url" && ! "$url" =~ ^# ]]; then
                temp_file="remote_playlist_${line_number}.m3u"
                echo "Downloading line ${line_number}: $url to $temp_file"
                
                # Use curl with -f (fail fast) for better error handling and 
                # a short connect timeout. We keep -L for redirects.
                if curl -L -f --connect-timeout 15 "$url" -o "$temp_file"; then
                  echo "✅ Successfully downloaded: $url"
                else
                  echo "❌ Failed to download: $url"
                  # Create an empty file or a file with a failure message 
                  # so we can detect and skip it later.
                  echo "#EXTM3U" > "$temp_file"
                  echo "#ERROR_DOWNLOAD_FAILED $url" >> "$temp_file"
                fi
              fi
            done < "channels.txt"
          else
            echo "⚠️ channels.txt not found, skipping remote playlist download."
          fi
        shell: bash # Use bash for the `while read` loop logic.

      - name: Run Python scripts and combine outputs
        run: |
          # Activate the virtual environment to ensure all installed packages are available.
          source venv/bin/activate
          
          # Start the main playlist file with the #EXTM3U header.
          echo "#EXTM3U" > MyStuff.m3u

          # Define an associative array to map each script to its expected output filename.
          declare -A script_outputs
          script_outputs=(
            ["FSC.py"]="S1.m3u"
            ["FS.py"]="S2.m3u8"
            ["PP.py"]="S3.m3u"
            ["TML.py"]="S4.m3u8"
            ["WC.py"]="S5.m3u8"
          )

          ## 1. APPEND OUTPUTS FROM PYTHON SCRIPTS
          echo "--- Combining content from Python scripts ---"
          for script in "${!script_outputs[@]}"; do
            echo "Running $script..."
            # Run the script from the current directory. Use || to continue if a script fails.
            python "$script" || echo "⚠️ $script failed but continuing..."
            
            output_file="${script_outputs[$script]}"
            if [ -f "$output_file" ]; then
              echo "Appending $output_file to MyStuff.m3u, skipping first 10 lines"
              # Use tail -n +11 to skip the first 10 lines of each individual playlist.
              tail -n +11 "$output_file" >> MyStuff.m3u
            else
              echo "⚠️ $output_file not found, skipping"
            fi
          done

          ## 2. APPEND CONTENTS FROM REMOTE PLAYLISTS (ALREADY DOWNLOADED)
          echo "--- Appending pre-downloaded remote playlists ---"
          # Find all the pre-downloaded remote playlist files.
          downloaded_files=$(find . -maxdepth 1 -type f -name 'remote_playlist_*.m3u' | sort -V)
          
          if [ -n "$downloaded_files" ]; then
            for temp_file in $downloaded_files; do
              # Check if the file contains the failure error marker
              if grep -q "#ERROR_DOWNLOAD_FAILED" "$temp_file"; then
                echo "⚠️ Skipping failed download: $(basename "$temp_file")"
              else
                echo "Appending content from: $(basename "$temp_file"), skipping first 10 lines"
                # Append the content, skipping the first 10 lines
                tail -n +11 "$temp_file" >> MyStuff.m3u
              fi
              # Clean up the temporary file
              rm "$temp_file"
            done
          else
            echo "No remote playlist files found to append."
          fi
        shell: bash

      - name: Upload combined playlist to Dropbox
        # Use a third-party action to securely upload the final playlist.
        uses: gomes042/gh-actions-dropbox/files/upload@23ce81287e83f01c19c9f60b1849b746db6616b5
        with:
          # Use GitHub secrets to authenticate with Dropbox.
          DROPBOX_APP_KEY: ${{ secrets.DROPBOX_APP_KEY }}
          DROPBOX_APP_SECRET: ${{ secrets.DROPBOX_APP_SECRET }}
          DROPBOX_REFRESH_TOKEN: ${{ secrets.DROPBOX_REFRESH_TOKEN }}
          # Specify the source file to upload and the destination path in Dropbox.
          source_path: MyStuff.m3u
          DEST_PATH: /MyStuff/MyStuff.m3u

      # - name: Signal success to Cronitor
      #  run: curl --silent "https://cronitor.link/p/2a7e1594aaf843d0ab2a037849f79ec2/playwright-main"
